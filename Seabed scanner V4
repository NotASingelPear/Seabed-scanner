--Recieves new calculated points and draws graphics

--maxPoints = property.getNumber("Maximum datapoints") or 10000

gN = input.getNumber
sN = output.setNumber
sC = screen.setColor
dRF = screen.drawRectF
f = math.floor
pi2 = math.pi/2
cos = math.cos
sin = math.sin
set_range = 350
gridFilter, heightFilter = 10, 1






P = {}
record = {}


function check(x, y, w, h)
	return touchX >= x and touchX <= x + (w or 0) and touchY >= y and touchY <= y + (h or 0)
end

function Round10(n)
	return f(( n )/10+.5)*10
end

function color(n)
	if n < 0 then
		sC(255,0,0)
	elseif n <= 1 then	
		if n < 1/8 then	
			a={255,255,0}	--yellow
			b={0,255,0}
		elseif n<2/8 then
			a={0,255,0}	
			b={0,153,76}	--dark green
		elseif n<3/8 then
			a={0,153,76}
			b={0,255,255}	--light blue
		elseif n<4/8 then
			a={0,255,255}
			b={0,76,153}	--blue
		elseif n<5/8 then
			a={0,76,153}
			b={0,0,255}		--dark blue
		elseif n<6/8 then
			a={0,0,255}
			b={76,0,153}	--purple
		elseif n<7/8 then
			a={76,0,153}
			b={255,0,255}	--pink
		else
			a={255,0,255}
			b={80,0,50}		--dark pink
		end
		
		dr=b[1]-a[1]
		dg=b[2]-a[2]
		db=b[3]-a[3]

		k=n/(1/8) - f(n/(1/8))
		sC(
			a[1] + dr*k, 
			a[2] + dg*k,
			a[3] + db*k
		)
	else
		sC(0,0,0)
	end
end



drawCenterY = -50
pixelRadius = 71
FOV = math.rad(45)
cutoffY = 30
--arcDivisions = 45
vehiclerelativePosY = drawCenterY + pixelRadius - cutoffY		--Relative to drawCenterY (center of radar display calculation)

focusPoints = {}
recordKeeper = {}
for angle = -FOV/2+0.003, FOV/2, 0.01 do
	for lengthUnit = pixelRadius - cutoffY, pixelRadius, 0.5 do
		if math.cos(angle) * lengthUnit > pixelRadius - cutoffY then
			local x = ((math.cos(angle + math.pi/2) * lengthUnit) + 0.5) //1
			local y = ((drawCenterY + (math.sin(angle + math.pi/2) * lengthUnit)) + 0.5) //1
			
			if not recordKeeper[x] then
				recordKeeper[x] = {}
			end
			
			if recordKeeper[x] and not recordKeeper[x][y] then
				vesselAngle = math.atan(y - vehiclerelativePosY, x) - math.pi/2
				vesselDistUnits = math.sqrt(x^2 + (y - vehiclerelativePosY)^2)
				
				table.insert(focusPoints, {
					vesselAngle = vesselAngle,
					vesselDistUnits = vesselDistUnits,
					screenPosX = x,
					screenPosY = y
				})
				recordKeeper[x][y] = true
			end
		end
	end
end
-- print(#focusPoints)
recordKeeper = nil


function onTick()
	isPressing = input.getBool(1)
	touchX = input.getNumber(7)
	touchY = input.getNumber(8)
	hi_boundary,lo_boundary = -2, -200--gN(1),gN(2)
	run = input.getBool(3)
	draught = 0 --
	rec_size = 20000
	
	pos = {
	    	x = gN(1),	--east
    	y = gN(3),	--north
    	z = gN(2)	--up
	    }
    -- Looking towards laser sensor from behind
	roll = gN(4)	--left
    pitch = gN(5)	--up
    azimuth = gN(6)	--left
	
	-- test = gN(6)
	
	test1 = gN(9)
	test2 = gN(10)
	
	
	if run then
		--startCh = 9
		for i = 9, 32 do
			filteredPos = {
			    	-- x = gN(startCh + i)//1,
			    	-- y = gN(startCh+1 + i)//1,
			    	-- z = gN(startCh+2 + i)//1
			    	x = gN(i)//1,
			    	y = gN(i+1)//1,
			    	z = gN(i+2)//1
			    }
			if filteredPos.x ~= 0 then
		    	if not P[filteredPos.x] then
					P[filteredPos.x] = {}
				end
				
				if P[filteredPos.x][filteredPos.y] and P[filteredPos.x][filteredPos.y].readings < 10 then
					if P[filteredPos.x][filteredPos.y].depth > draught-0.5 then
						P[filteredPos.x][filteredPos.y].depth = filteredPos.z
						P[filteredPos.x][filteredPos.y].readings = 10
					else
						P[filteredPos.x][filteredPos.y].readings = P[filteredPos.x][filteredPos.y].readings + 1
						P[filteredPos.x][filteredPos.y].read_sum = P[filteredPos.x][filteredPos.y].read_sum + filteredPos.z
						P[filteredPos.x][filteredPos.y].depth = P[filteredPos.x][filteredPos.y].read_sum / P[filteredPos.x][filteredPos.y].readings
						
					end
				else
					P[filteredPos.x][filteredPos.y] = {depth = filteredPos.z, readings = 1, read_sum = filteredPos.z}
					if filteredPos.z > draught-0.5 then P[filteredPos.x][filteredPos.y].readings = 10 end
					table.insert(record, 1, {filteredPos.x, filteredPos.y})
					if #record > rec_size then
						P[ record[rec_size+1][1] ][ record[rec_size+1][2] ] = nil
						record[rec_size+1] = nil
					end
					-- print(filteredPos.x, filteredPos.y, filteredPos.z)
				end
			end
		end
	else
		P = {}
		record = {}
	end
	
	--P = {[0] = {[200] = -100}}

end



-- point = focusPoints[1000]
-- print(point.vesselAngle)
-- print(point.vesselDistUnits)

--print(0 + math.cos(0 + point.vesselAngle) * ((point.vesselDistUnits * 10 + gridFilter/2) // gridFilter * gridFilter))


function onDraw()
	w, h = screen.getWidth(), screen.getHeight()

	-- if isPressing then
	-- 	screen.drawText(1, 1, touchX .. ", " .. touchY)
	-- end

	if run then
		clickedOnRadarDispThisTick = false
		for _, focuspoint in pairs(focusPoints) do
			--screen.drawRectF(w/2 + focuspoint.screenPosX, h/2 - focuspoint.screenPosY, 1, 1)
			
			worldPos = {
				x = (pos.x + math.cos(azimuth + focuspoint.vesselAngle) * focuspoint.vesselDistUnits * 10 + gridFilter/2) // gridFilter * gridFilter,
				y = (pos.y + math.sin(azimuth + focuspoint.vesselAngle) * focuspoint.vesselDistUnits * 10 + gridFilter/2) // gridFilter * gridFilter
			}
			
			if P[worldPos.x] and P[worldPos.x][worldPos.y] then
				color(P[worldPos.x][worldPos.y].depth / lo_boundary)
				--sC(255, 0, 0)
			else
				sC(30,30,30)
			end
			
			screen.drawRectF(w/2 + focuspoint.screenPosX, h/2 - focuspoint.screenPosY, 1, 1)
			
			
			
			
			if isPressing and check(w/2 + focuspoint.screenPosX, h/2 - focuspoint.screenPosY) then--check(w + relativePos.x, h - relativePos.y) then
				clickedOnRadarDispThisTick = true
				clickedOnRadarDisp = true
				clickedFocuspoint = focuspoint
				
				-- sC(255, 100, 0)
				-- screen.drawText(2, h-17, string.format("%.0f", focuspoint.screenPosX) .. ", " .. string.format("%.0f", focuspoint.screenPosY))
				-- screen.drawText(2, h-10, string.format("%.0f", math.deg(worldPos.x)) .. ", " .. string.format("%.0f", worldPos.y))
				-- screen.drawCircle(w/2 + focuspoint.screenPosX, h/2 - focuspoint.screenPosY, 1)
			end	
			
			if isPressing and not clickedOnRadarDispThisTick then
				clickedOnRadarDisp = false
			end
		end
		
		if clickedOnRadarDisp then
				sC(255, 100, 0)
				
				worldPos = {
					x = (pos.x + math.cos(azimuth + clickedFocuspoint.vesselAngle) * clickedFocuspoint.vesselDistUnits * 10 + gridFilter/2) // gridFilter * gridFilter,
					y = (pos.y + math.sin(azimuth + clickedFocuspoint.vesselAngle) * clickedFocuspoint.vesselDistUnits * 10)
				}
				
				--screen.drawText(2, h-17, string.format("%.0f", clickedFocuspoint.screenPosX) .. ", " .. string.format("%.0f", clickedFocuspoint.screenPosY))
				screen.drawTextBox(2, h/2-10, w, 7, string.format("%.0f", worldPos.x), 0, 0)-- .. ", " .. string.format("%.0f", worldPos.y))
				screen.drawTextBox(2, h/2-4, w, 7, string.format("%.0f", worldPos.y), 0, 0)
				screen.drawCircle(w/2 + clickedFocuspoint.screenPosX, h/2 - clickedFocuspoint.screenPosY, 1)
		end
		
		-- coll_warn = false
		-- for i=0,42 do
		-- 	dis = (i/42)*set_range
		-- 	req_x = Round10( pos.x + cos(pi2-azimuth) * dis )
		-- 	req_y = Round10( pos.y + sin(pi2-azimuth) * dis )
			
		-- 	if P[req_x] and P[req_x][req_y] then
		-- 		depth = P[req_x][req_y].z-zero_ref
		-- 		if depth > set_depth then
		-- 			if depth < draught-3 then
		-- 				sC(0,255,0)
		-- 			elseif depth > draught-0.5 then
		-- 				if dis > 30 then
		-- 					if (dis / speed) < warn_sec then
		-- 						coll_warn = true
		-- 					end
		-- 				end
		-- 				sC(255,0,0)
		-- 			else
		-- 				sC(255,255,0)
		-- 			end
		-- 			dRF(11 + i, 47 + 14*depth/set_depth, 1, 1)
		-- 		end
		-- 	end
		-- end
		sC(255, 255, 255)
		screen.drawTextBox(1, 1, w, 5, string.format("%.2f", azimuth), 0, 0)
		
		
		
		-- screen.drawText(10, 10, #record)
		-- --if record[1] then
		-- 	screen.drawText(10, 16, test1)
		-- 	screen.drawText(10, 22, test2)
		-- --end
	end
end




---------------------------------------------------------------------------------------




--Recieves new measurements and calculates positions + througput of composite signal
gN,sN,gB=input.getNumber,output.setNumber,input.getBool
dT=screen.drawText
pi=math.pi
co=math.cos
si=math.sin

tick = 0


lowestDetectable, highestDetectable = 10, 4000
gridFilter, heightFilter = 10, 1
sensorInputStartCh = 9
outStartCh = 9

function multiplyVector(vector, multiplier)
	return {
		x = vector.x * multiplier,
		y = vector.y * multiplier,
		z = vector.z * multiplier
	}
end

function addVectors(...)
	local result = {x = 0, y = 0, z = 0}
	for _, vector in pairs({...}) do
		result.x = result.x + vector.x
		result.y = result.y + vector.y
		result.z = result.z + vector.z
	end
	return result
end





function rotX(x,r)
    return {x[1],co(r)*x[2]-si(r)*x[3],si(r)*x[2]+co(r)*x[3]}
end
function rotY(x,r)
    return {co(r)*x[1]+si(r)*x[3],x[2],-si(r)*x[1]+co(r)*x[3]}
end
function rotZ(x,r)
    return {co(r)*x[1]-si(r)*x[2],si(r)*x[1]+co(r)*x[2],x[3]}
end



function onTick()
	for i = 1, 32 do
		output.setNumber(i, input.getNumber(i))
		output.setBool(i, input.getBool(i))
	end
	
	
	--

    ex,ey,ez=gN(4),gN(5),gN(6)
    
    v1={0,0,1}
    v1=rotZ(rotY(rotX(v1,ex),ey),ez)
    hdg=math.atan(v1[1],v1[3])
    elv=math.atan(v1[2],math.sqrt(v1[1]^2+v1[3]^2))
    
    v2={1,0,0}
    v2=rotZ(rotY(rotX(v2,ex),ey),ez)
    
    v3={1,0,0}
    v3=rotY(rotX(v3,elv),hdg)
    
    crs={v2[2]*v3[3]-v2[3]*v3[2],v2[3]*v3[1]-v2[1]*v3[3],v2[1]*v3[2]-v2[2]*v3[1]}    --sin
	sgn=(v1[1]*crs[1]+v1[2]*crs[2]+v1[3]*crs[3]>=0) and 1 or -1
	crs=math.sqrt(crs[1]^2+crs[2]^2+crs[3]^2)*sgn
    dot=v2[1]*v3[1]+v2[2]*v3[2]+v2[3]*v3[3]    --cos
    rol=math.atan(crs,dot)
    hdg=(-hdg+pi/2)%(pi*2)
    
    --
    
    
    pos = {
    	x = gN(1),	--east
    	y = gN(3),	--north
    	z = gN(2),	--up
    }
    roll = rol	--left
    pitch = elv	--up
    azimuth = hdg	--left
    
    run = gB(3)
    
    
    
	if run then
	    vector = {
			right_noRoll = {
				x = math.cos(azimuth-math.pi/2),
				y = math.sin(azimuth-math.pi/2),
				z = 0
			},
			up_noRoll = {
				x = math.cos(azimuth+math.pi) * math.sin(pitch),
				y = math.sin(azimuth+math.pi) * math.sin(pitch),
				z = math.cos(pitch)
			}
		}
			

		vector.right = {
			x = vector.up_noRoll.x * math.sin(roll) + vector.right_noRoll.x * math.cos(roll),
			y = vector.up_noRoll.y * math.sin(roll) + vector.right_noRoll.y * math.cos(roll),
			z = vector.up_noRoll.z * math.sin(-roll) + vector.right_noRoll.z * math.cos(-roll)
		}

		
		-- print(vector.up_noRoll)
		-- print(dist(vector.right))
		-- print(vector.right)
		
		vector.forward = {
			x = math.cos(azimuth) * math.cos(pitch),
	    	y = math.sin(azimuth) * math.cos(pitch),
	    	z = math.sin(pitch)
	    }
	    
		vector.up = {
			x = vector.up_noRoll.x * math.cos(roll) + vector.right_noRoll.x * math.sin(roll),
			y = vector.up_noRoll.y * math.cos(roll) + vector.right_noRoll.y * math.sin(roll),
			z = vector.up_noRoll.z * math.cos(roll) + vector.right_noRoll.z * math.sin(roll)
		}
		
		--SENSOR ORIENTATION: looking at sensor face - Big arrow facing down, small arrow facing left
	    for i = 9, 32, 3 do
		    measuredDis = gN(i)
		    angleX = gN(1 + i) * math.pi/4		--right
		    angleY = gN(2 + i) * math.pi/4		--up
		    if measuredDis > lowestDetectable and measuredDis < highestDetectable then
			    sensorRelative = {
			    	x = math.sin(angleX) * math.cos(angleY) * measuredDis,	--right
			    	y = math.cos(angleX) * math.cos(angleY) * measuredDis,	--forward
				    z = math.sin(angleY) * measuredDis	--up
				}
				measuredPos = addVectors(
					pos,
					multiplyVector(vector.right, sensorRelative.x),
					multiplyVector(vector.forward, sensorRelative.y),
					multiplyVector(vector.up, sensorRelative.z)
				)
				
				filteredPos = {
			    	x = (measuredPos.x + gridFilter/2) // gridFilter * gridFilter,
			    	y = (measuredPos.y + gridFilter/2) // gridFilter * gridFilter,
			    	z = (measuredPos.z + heightFilter/2) // heightFilter * heightFilter
			    }
			    
			    -- sN(outStartCh + i-1, filteredPos.x)
			    -- sN(outStartCh+1 + i-1, filteredPos.y)
			    -- --sN(10, filteredPos.y)
			    -- sN(outStartCh+2 + i-1, filteredPos.z)
				--print(i, measuredPos)
				
				sN(i, filteredPos.x)
			    sN(i+1, filteredPos.y)
			    sN(i+2, filteredPos.z)
			else
				sN(i, 0)
			    sN(i+1, 0)
			    sN(i+2, 0)
			end
	    end
	end
    
    
    
    
    
    
    
    
    
    
    tick = tick + 1
    if tick % 60 == 0 then
		filteredPosToDisplay = filteredPos
	end
    
    sN(4, roll)
    sN(5, pitch)
    sN(6, azimuth)   
end


function onDraw()
	if run then
		w, h = screen.getWidth(), screen.getHeight()
		dT(1, 1, "X: " .. string.format("%.1f", pos.x))
		dT(1, 7, "Y: " .. string.format("%.1f", pos.y))
		dT(1, 13, "Z: " .. string.format("%.1f", pos.z))
		
		dT(1, 20, "P: " .. string.format("%.1f", pitch))
		dT(1, 26, "A: " .. string.format("%.1f", azimuth))
		dT(1, 32, "R: " .. string.format("%.1f", roll))
		
		dT(1, 39, "MEAS: " .. measuredDis//1)
		dT(1, 45, "A-X: " .. angleX)
		dT(1, 51, "A-Y: " .. angleY)
		
		dT(1, 60, string.format("%.3f", vector.right.x))
		dT(1, 66, string.format("%.3f", vector.right.y))
		dT(1, 72, string.format("%.3f", vector.right.z))
		
		-- if filteredPosToDisplay then
		-- 	--dT(1, h-7, string.format("%.0f", filteredPosToDisplay.x), string.format("%.0f", filteredPosToDisplay.y), string.format("%.0f", filteredPosToDisplay.z))
		-- 	dT(1, h-21, filteredPosToDisplay.x)
		-- 	dT(1, h-15, filteredPosToDisplay.y) 
		-- 	dT(1, h-9, filteredPosToDisplay.z)
		-- end
	else
		dT(1, 1, "run = off")
	end
	
end


----------------------------------------------------------------------

-- Sets sensors scan angles



nSensors = 8
cycleTicks = 150
tick = 0

rows = 45
columns = 30
function getLaserDirection(n)
	local x = (rows * columns * n) % columns / columns
	local y = ((rows * columns * n) // columns / rows)^3
	return x * 2 - 1, -(0.03 + y*0.97)
end

FOV = math.min(90, math.max(20, property.getNumber("Field of view") or 90) ) / 90
brt = property.getNumber("Brightness") or 255
scanLines = 7
cycleTime = 60 // scanLines * scanLines
displayTime = 60 * 2
firstRun = true
--tick = 0

setupMirroring = {
	{x = 0.6, y = -0.2, size = 0.7},
	{x = 0.2, y = -0.2, size = 0.4},
	{x = 0.25, y = -0.4, size = 0.5},
	{x = 0.3, y = -0.6, size = 0.6}
}

aimBoxes = {}
for index, rectangle in ipairs(setupMirroring) do
	for i = -1, 1, 2 do
		local targetIndex = (index + (i+1)/2 * #setupMirroring) // 1
		aimBoxes[targetIndex] = {
			startX = (rectangle.x + rectangle.size/2) * i,
			rangeX = rectangle.size * -i,
			startY = rectangle.y + rectangle.size/2,
			rangeY = -rectangle.size
		}
	end
end


function clamp(value, min, max)
	return math.min(max, (math.max(min, value)))
end
	
function onTick()
	
	run = input.getBool(3)
	roll = input.getNumber(4)-- * (-math.pi*2)	-- CW is positive
	
	if (property.getBool("Display start-up screen") or false) and run and tick < ((startTick or 0) + displayTime) then
		showGraphics = true
	else
		showGraphics = false
		if firstRun then
			startTick = tick
		end
	end
	
	if run then
		if firstRun and showGraphics then
			sensors = 0
			inStartCh = 9
			for sensorID, aimBox in pairs(aimBoxes) do
				aimBox.detected = input.getNumber(inStartCh + (sensorID-1) * 3) ~= 0
				sensors = sensors + (aimBox.detected and 1 or 0)
			end
		end
		
		
		xStep = (tick%cycleTime // scanLines) / scanLines
		yStep = (tick % scanLines / scanLines) / (1-(1/scanLines))
		
		
		outStartCh = 9
    	for i = 1, nSensors do
	    	local x, y = getLaserDirection((tick % cycleTicks / cycleTicks + i/nSensors) % 1)
	    	output.setNumber(outStartCh + (i-1) * 3 + 1, x)
	    	output.setNumber(outStartCh + (i-1) * 3 + 2, y)
    	end	
	
		-- for sensorID, aimBox in pairs(aimBoxes) do
		-- 	aimXNoRoll = aimBox.startX + aimBox.rangeX * xStep
		-- 	aimYNoRoll = aimBox.startY + aimBox.rangeY * yStep
		-- 	length = math.sqrt(aimXNoRoll^2 + aimYNoRoll^2)
		-- 	angleNoRoll = math.atan(aimYNoRoll, aimXNoRoll)
		-- 	aimX = clamp(math.cos(angleNoRoll + roll) * length * FOV, -1, 1)
		-- 	aimY = clamp(math.sin(angleNoRoll + roll) * length * FOV, -1, 1)
			
			
			--output.setNumber(outStartCh + (sensorID-1)*3 + 1, input.getNumber(1))--aimX)
			--output.setNumber(outStartCh + (sensorID-1)*3 + 2, input.getNumber(2))--aimY)
			
			--output.setNumber(outStartCh + (sensorID-1)*3 + 1, math.random(-70, 70)/100)--aimX)
			
			--output.setNumber(outStartCh + (sensorID-1)*3 + 2, math.random(-40, 0)/100)--aimY)
			
			--output.setNumber(outStartCh + (sensorID-1)*3 + 2, math.random(-70, -10)/100)
			
			
			
			
			
			
		-- end
		
		firstRun = false
	end
	
	output.setBool(3, run and not showGraphics)
	tick = tick + 1
end



sC = screen.setColor
dTB = screen.drawTextBox

function onDraw()
	w, h = screen.getWidth()/2, screen.getHeight()/2
	len = math.min(w, h)
	
	if showGraphics then
		sC(255, 255, 255)
		dTB(
			w - len, 
			h - len + 3, 
			len * 2,
			12,
			"VERSION 1.0\n-------------------",
			0, 0)
		
		sC(0, 255, 0)
		dTB(
			w - len, 
			h - len + 19, 
			len * 2,
			6,
			"FOV:   " .. string.format("%.0f", FOV*90) .. "'",
			0, 0)
		
		dTB(
			w - len, 
			h - len + 26, 
			len * 2,
			6,
			"SENSORS: " .. string.format("%.0f", sensors or 0),
			0, 0)
		
		
		for _, aimBox in ipairs(aimBoxes) do
			if aimBox.detected then
				sC(0, 255, 0,  math.abs(10/aimBox.rangeX))
				screen.drawRectF(
					w + aimBox.startX * len,
					h - aimBox.startY * len,
					aimBox.rangeX * len, 
					-aimBox.rangeY * len
					)
			end
		end
		
		
		colors = #aimBoxes
		colorNo = 0
		for sensorID, aimBox in ipairs(aimBoxes) do
			startX = aimBox.startX
			startY = aimBox.startY
			rangeX = aimBox.rangeX
			rangeY = aimBox.rangeY
			
			if aimBox.detected then
				sC(255 / colors * colorNo, 255 - 255 / colors * colorNo, 0)
			else
				sC(255, 0, 0)
				screen.drawLine(
				w + startX * len,
				h - startY * len,
				w + (startX + rangeX) * len,
				h - (startY + rangeY) * len
				)
				screen.drawLine(
				w + startX * len,
				h - (startY + rangeY) * len,
				w + (startX + rangeX) * len,
				h - startY * len
				)
			end
			
			
			screen.drawRectF(
				w + (startX + rangeX/2) * len ,
				h - (startY + rangeY/2) * len,
				1, -1
				)
			screen.drawRect(
				w + startX * len,
				h - startY * len,
				rangeX * len, 
				-rangeY * len
				)
			screen.drawText(
				w + (startX + (sensorID <= 4 and 0 or rangeX)) * len + 1,
				h - startY * len + 1,
				sensorID
				)
			colorNo = colorNo + 1
		end
		
		sC(0, 0, 0, 255 - brt*255)
		screen.drawRectF(1, 1, w*2, h*2)




------------------------------------------------------

-- Drawing of symbols and handles touch

--Recieves new calculated points and draws graphics

--maxPoints = property.getNumber("Maximum datapoints") or 10000

gN = input.getNumber
sN = output.setNumber
gB = input.getBool
sB = output.setBool
sC = screen.setColor
dRF = screen.drawRectF
dR = screen.drawRect
dT = screen.drawText
dTB = screen.drawTextBox
dL = screen.drawLine
f = math.floor
pi2 = math.pi / 2
cos = math.cos
sin = math.sin
gridFilter, heightFilter = 10, 1
prevPos = { x = 0, y = 0 }
tick = 0
displayRange = 300
vertDispDepth = -200
coll_warn_startTick = -math.huge



refreshRate = property.getNumber("Refresh rate") --per seconds
useAvgCalc = property.getBool("Fill empty pixels with average values")
draught = property.getNumber("Draught (M)") or 0

P = {}
record = {}


function check(x, y, w, h)
    return touchX >= x and touchX <= x + (w or 0) and touchY >= y and touchY <= y + (h or 0)
end

function color(n)
    if n < 0 then
        sC(255, 0, 0)
    elseif n <= 1 then
        if n < 1 / 8 then
            a = { 255, 255, 0 } --yellow
            b = { 0, 255, 0 }
        elseif n < 2 / 8 then
            a = { 0, 255, 0 }
            b = { 0, 153, 76 } --dark green
        elseif n < 3 / 8 then
            a = { 0, 153, 76 }
            b = { 0, 255, 255 } --light blue
        elseif n < 4 / 8 then
            a = { 0, 255, 255 }
            b = { 0, 76, 153 } --blue
        elseif n < 5 / 8 then
            a = { 0, 76, 153 }
            b = { 0, 0, 255 } --dark blue
        elseif n < 6 / 8 then
            a = { 0, 0, 255 }
            b = { 76, 0, 153 } --purple
        elseif n < 7 / 8 then
            a = { 76, 0, 153 }
            b = { 255, 0, 255 } --pink
        else
            a = { 255, 0, 255 }
            b = { 80, 0, 50 } --dark pink
        end

        dr = b[1] - a[1]
        dg = b[2] - a[2]
        db = b[3] - a[3]

        k = n / (1 / 8) - f(n / (1 / 8))
        sC(
            a[1] + dr * k,
            a[2] + dg * k,
            a[3] + db * k
        )
    else
        sC(0, 0, 0)
    end
end

drawCenterY = -50
pixelRadius = 71
FOV = math.rad(43)
cutoffY = 30
vehiclerelativePosY = drawCenterY + pixelRadius -
cutoffY --Relative to drawCenterY (center of radar display calculation)

focusPoints = {}
recordKeeper = {}


function dButton(x, y, text, var)
        sC(255, 255, 255)
        if var then
            dRF(x, y, 5, 5)
        else
            dR(x, y, 5, 5)
        end
        sC(0, 255, 0)
        dT(x + 1, y, text)
    end

for angle = -FOV / 2, FOV / 2, 0.01 do
    for lengthUnit = pixelRadius - cutoffY, pixelRadius, 0.5 do
        if math.cos(angle) * lengthUnit > pixelRadius - cutoffY then
            local x = ((math.cos(angle + math.pi / 2) * lengthUnit) + 0.5) // 1
            local y = ((drawCenterY + (math.sin(angle + math.pi / 2) * lengthUnit)) + 0.5) // 1

            if not recordKeeper[x] then
                recordKeeper[x] = {}
            end

            if recordKeeper[x] and not recordKeeper[x][y] then
                vesselAngle = math.atan(y - vehiclerelativePosY, x) - math.pi / 2
                vesselDistUnits = math.sqrt(x ^ 2 + (y - vehiclerelativePosY) ^ 2)

                table.insert(focusPoints, {
                    vesselAngle = vesselAngle,
                    vesselDistUnits = vesselDistUnits,
                    relScreenPosX = x,
                    relScreenPosY = y,
                    depth = 0
                })
                recordKeeper[x][y] = true
            end
        end
    end
end
recordKeeper = nil

function findAvgDepth(x, y)
    local surroundingPoints = {}

    local i = 1
    local maxIterations = 5
    local gf = gridFilter
    while #surroundingPoints < 3 and i <= maxIterations do
        for y1 = y - i * gf, y + i * gf, i * 2 * gf do
            for x1 = x - (i - 1) * gf, x + (i - 1) * gf, gf do
                if P[x1] and P[x1][y1] then
                    table.insert(surroundingPoints, P[x1][y1].depth)
                end
            end
        end

        for x1 = x - i * gf, x + i * gf, i * 2 * gf do
            for y1 = y - i * gf, y + i * gf, gf do
                if P[x1] and P[x1][y1] then
                    table.insert(surroundingPoints, P[x1][y1].depth)
                end
            end
        end


        i = i + 1
    end

    if #surroundingPoints ~= 0 then
        local totalDepth = 0
        for _, depth in ipairs(surroundingPoints) do
            totalDepth = totalDepth + depth
        end
        local avg = totalDepth / #surroundingPoints
        return avg
    else
        return false
    end
end


function onTick()
	hasPressed = not isPressing
    isPressing = gB(1) or gB(2)
    click = isPressing and hasPressed
    touchX = gN(7)
    touchY = gN(8)
    hi_boundary, lo_boundary = gN(7),gN(8)
    run = gB(3) and tick > 1 --testing
    draught = 0                         --
    rec_size = 10000

    --print((-50 - hi_boundary) / (lo_boundary - hi_boundary))

    pos = {
        x = gN(1), --east
        y = gN(3)  --north
    }
    -- Looking towards laser sensor from behind
    azimuth = gN(6) --left
    
    
    collisionWarnMuted = gB(4)



    if run then
        for i = 9, 32, 3 do
            filteredPos = {

                x = gN(i) // 1,
                y = gN(i + 1) // 1,
                z = gN(i + 2) // 1
            }
            if filteredPos.x ~= 0 then
                if not P[filteredPos.x] then
                    P[filteredPos.x] = {}
                end

                if P[filteredPos.x][filteredPos.y] and P[filteredPos.x][filteredPos.y].readings < 10 then
                    if P[filteredPos.x][filteredPos.y].depth > draught - 0.5 then
                        P[filteredPos.x][filteredPos.y].depth = filteredPos.z
                        P[filteredPos.x][filteredPos.y].readings = 10
                    else
                        P[filteredPos.x][filteredPos.y].readings = P[filteredPos.x][filteredPos.y].readings + 1
                        P[filteredPos.x][filteredPos.y].read_sum = P[filteredPos.x][filteredPos.y].read_sum +
                            filteredPos.z
                        P[filteredPos.x][filteredPos.y].depth = P[filteredPos.x][filteredPos.y].read_sum /
                            P[filteredPos.x][filteredPos.y].readings
                    end
                else
                    P[filteredPos.x][filteredPos.y] = { depth = filteredPos.z, readings = 1, read_sum = filteredPos.z }
                    if filteredPos.z > draught - 0.5 then P[filteredPos.x][filteredPos.y].readings = 10 end
                    table.insert(record, 1, { filteredPos.x, filteredPos.y })
                    if #record > rec_size then
                        P[record[rec_size + 1][1]][record[rec_size + 1][2]] = nil
                        record[rec_size + 1] = nil
                    end
                end
            end
        end


    end
    
    
    zoom_in = isPressing and check(w / 2 - 16, 2, 5, 5)
    if zoom_in and click then
    	displayRange = math.max(displayRange - 100, 100)
    end
    
    zoom_out = isPressing and check(w / 2 + 12, 2, 2, 5, 5)
    if zoom_out and click then
    	displayRange = math.min(displayRange + 100, 3000)
    end
    
    higher = isPressing and check(w / 2 - 27, h / 2 + 15, 5, 5)
    if higher and click then
    	vertDispDepth = math.min(vertDispDepth + 100, -100)
    end
    
    lower = isPressing and check(w / 2 - 27, h / 2 + 23, 5, 5)
    if lower and click then
    	vertDispDepth = math.max(vertDispDepth - 100, -1000)
    end
    
    showOptionsPage = isPressing and check(2, 2, 5, 5, 5, 5)
    
    
    coll_warn_dur = 120
    if coll_warn or gB(5) and not collisionWarnMuted then
    	coll_warn_startTick = tick
    end
    
	coll_warn_active = (tick - coll_warn_startTick) < coll_warn_dur 
    	
    
    
    sN(7, displayRange)

    tick = tick + 1
end



function onDraw()
    w, h = screen.getWidth(), screen.getHeight()



	dButton(2, 2, "", showOptionsPage)
    sC(0, 255, 0)
    dRF(3, 3, 3, 3)

	if collisionWarnMuted then
	    sC(255, 255, 255)
	    screen.drawCircle(w-5, 5, 3)
	    sC(255, 0, 0)
	    dT(w-6, 2, "!")
	end

    sC(255, 255, 255)
    dT(w / 2 + 23, h / 2 + 15, 0)
    dT(w / 2 + 23, h / 2 + 23, string.format("%.0f", -vertDispDepth / 100))

    dT(4, h / 2 - 8, string.format("%.0f", -hi_boundary / 100))
    dT(4, h / 2 + 2, string.format("%.0f", -lo_boundary / 100))

    dTB(1, 2, w, 6, displayRange, 0, 0)
    dButton(w / 2 - 16, 2, "+", zoom_in)
    
    --screen.drawRect(w / 2 - 16, 2, 5, 5)
    
    dButton(w / 2 + 12, 2, "-", zoom_out)
    dButton(w / 2 - 27, h / 2 + 15, "+", higher)
    dButton(w / 2 - 27, h / 2 + 23, "-", lower)

    steps = 20
    startI = -0.1
    endI = 1
    for i = 0, 1, 1 / steps do
        color(startI + i * (endI - startI))
        dRF(2, h / 2 - 10 + i * steps, 1, 1)
    end



    drawCenterY = -50
    pixelRadius = 71
    FOV = math.rad(43)
    cutoffY = 30
    sC(255, 255, 255)

    dL(
        w / 2 + math.cos(math.pi / 2 + FOV / 2) * 71,
        h / 2 + 50 - math.sin(math.pi / 2 + FOV / 2) * 71,
        w / 2 + math.cos(math.pi / 2 + FOV / 2) * 43,
        h / 2 + 50 - math.sin(math.pi / 2 + FOV / 2) * 43
    )

    dL(
        w / 2 + math.cos(math.pi / 2 - FOV / 2 * 1.02) * 71 + 0.3,
        h / 2 + 50 - math.sin(math.pi / 2 - FOV / 2 * 1.02) * 71,
        w / 2 + math.cos(math.pi / 2 - FOV / 2 * 1.02) * 43 + 1,
        h / 2 + 50 - math.sin(math.pi / 2 - FOV / 2 * 1.02) * 43
    )

    dL(
        w / 2 + math.cos(math.pi / 2 + FOV / 2) * 43,
        h / 2 + 50 - math.sin(math.pi / 2 + FOV / 2) * 43,
        w / 2 + math.cos(math.pi / 2 - FOV / 2) * 43 + 2,
        h / 2 + 50 - math.sin(math.pi / 2 - FOV / 2) * 43
    )

    for i = -FOV / 2, FOV / 2, FOV / 60 do
        dRF(
            w / 2 + math.cos(math.pi / 2 + i) * 71,
            h / 2 + 50 - math.sin(math.pi / 2 + i) * 71,
            1,
            1
        )
    end


    sC(255, 255, 255)
    dR(w / 2 - 19, h / 2 + 14, 39, 15)

    if coll_warn_active then
    	sC(0,0,0)
    	dRF(w/2-27, 8, 55, 16)
    	sC(255,0,0)
    	dR(w/2-27, 8, 55, 16)
    	sC(255,255,255)
    	dTB(w/2-27, 10, 55, 16, "COLLISION", 0)
    	dTB(w/2-27, 16, 55, 16, "AHEAD", 0)
    end



    sC(0, 0, 0, brt)
    dRF(w / 2, h / 2, 70, 70)
end



	end	

end
