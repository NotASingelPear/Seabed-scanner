--Recieves new calculated points and draws graphics

gN = input.getNumber
sN = output.setNumber
sC = screen.setColor
dRF = screen.drawRectF
f = math.floor
pi2 = math.pi/2
cos = math.cos
sin = math.sin
set_range = 350
gridFilter, heightFilter = 10, 1
prevPos = {x = 0, y = 0}
tick = 0

refreshRate = property.getNumber("Refresh rate")--per seconds
useAvgCalc = property.getBool("Fill empty pixels with average values")
draught = property.getNumber("Draught (M)") or 0 *-1

P = {}
record = {}


function check(x, y, w, h)
	return touchX >= x and touchX <= x + (w or 0) and touchY >= y and touchY <= y + (h or 0)
end

function color(n)
	if n < 0 then
		sC(255,0,0)
	elseif n <= 1 then	
		if n < 1/8 then	
			a={255,255,0}	--yellow
			b={0,255,0}
		elseif n<2/8 then
			a={0,255,0}	
			b={0,153,76}	--dark green
		elseif n<3/8 then
			a={0,153,76}
			b={0,255,255}	--light blue
		elseif n<4/8 then
			a={0,255,255}
			b={0,76,153}	--blue
		elseif n<5/8 then
			a={0,76,153}
			b={0,0,255}		--dark blue
		elseif n<6/8 then
			a={0,0,255}
			b={76,0,153}	--purple
		elseif n<7/8 then
			a={76,0,153}
			b={255,0,255}	--pink
		else
			a={255,0,255}
			b={80,0,50}		--dark pink
		end
		
		dr=b[1]-a[1]
		dg=b[2]-a[2]
		db=b[3]-a[3]

		k=n/(1/8) - f(n/(1/8))
		sC(
			a[1] + dr*k, 
			a[2] + dg*k,
			a[3] + db*k
		)
	else
		sC(0,0,0)
	end
end



drawCenterY = -50
pixelRadius = 71
FOV = math.rad(43.5)
cutoffY = 30
vehiclerelativePosY = drawCenterY + pixelRadius - cutoffY		--Relative to drawCenterY (center of radar display calculation)

focusPoints = {}
recordKeeper = {}
for angle = -FOV/2, FOV/2, 0.01 do
	for lengthUnit = pixelRadius - cutoffY, pixelRadius, 0.5 do
		if math.cos(angle) * lengthUnit > pixelRadius - cutoffY then
			local x = ((math.cos(angle + math.pi/2) * lengthUnit) + 0.5) //1
			local y = ((drawCenterY + (math.sin(angle + math.pi/2) * lengthUnit)) + 0.5) //1
			
			if not recordKeeper[x] then
				recordKeeper[x] = {}
			end
			
			if recordKeeper[x] and not recordKeeper[x][y] then
				vesselAngle = math.atan(y - vehiclerelativePosY, x) - math.pi/2
				vesselDistUnits = math.sqrt(x^2 + (y - vehiclerelativePosY)^2)
				
				table.insert(focusPoints, {
					vesselAngle = vesselAngle,
					vesselDistUnits = vesselDistUnits,
					relScreenPosX = x,
					relScreenPosY = y,
					depth = 0
				})
				recordKeeper[x][y] = true
			end
		end
	end
end
recordKeeper = nil

function findAvgDepth(x, y)
	local surroundingPoints = {}
	
	local i = 1
	local maxIterations = 5
	local gf = gridFilter
	while #surroundingPoints < 3 and i <= maxIterations do
		for y1 = y - i * gf, y + i * gf, i*2 * gf do
			for x1 = x - (i-1) * gf, x + (i-1) * gf, gf do
				if P[x1] and P[x1][y1] then
					table.insert(surroundingPoints, P[x1][y1].depth)
				end
			end
		end
		
		for x1 = x - i * gf, x + i * gf, i*2 * gf do
			for y1 = y - i * gf, y + i * gf, gf do
				if P[x1] and P[x1][y1] then
					table.insert(surroundingPoints, P[x1][y1].depth)
				end
			end
		end
		
		
		i = i + 1
	end
	
	if #surroundingPoints ~= 0 then
		local totalDepth = 0
		for _, depth in ipairs(surroundingPoints) do
			totalDepth = totalDepth + depth
		end
		local avg = totalDepth / #surroundingPoints
		return avg
	else
		return false
	end
end

--P = {
--	[200] = {
		--[0] = {depth = -10},
		--[40] = {depth = -30},
		--[50] = {depth = -190}
	--}--,
	-- [170] = {
	-- 	[-20] = {depth = -30},
	-- 	[30] = {depth = -30},
	-- 	[40] = {depth = -50}
	-- },
	-- [160] = {
	-- 	[-40] = {depth = -50},
	-- 	[0] = {depth = 10},
	-- 	[20] = {depth = 100}
	-- },
	-- [250] = {
	-- 	[-80] = {depth = - 100}
	-- }
--}


function onTick()
	isPressing = input.getBool(1)
	--touchX = gN(7)
	--touchY = gN(8)
	hi_boundary, lo_boundary = gN(7),gN(8)
	run = input.getBool(3) and tick > 1	--testing
	draught = 0 --
	rec_size = 10000
	displayRange = gN(2)
	
	--print((-50 - hi_boundary) / (lo_boundary - hi_boundary))
	
	pos = {
	    x = gN(1),	--east
    	y = gN(3)	--north
	}
    -- Looking towards laser sensor from behind
	roll = gN(4)	--left
    pitch = gN(5)	--up
    azimuth = gN(6)	--left


	
	if run then
		for i = 9, 32, 3 do
			filteredPos = {

			    	x = gN(i)//1,
			    	y = gN(i+1)//1,
			    	z = gN(i+2)//1
			    }
			if filteredPos.x ~= 0 then
		    	if not P[filteredPos.x] then
					P[filteredPos.x] = {}
				end
				
				if P[filteredPos.x][filteredPos.y] and (P[filteredPos.x][filteredPos.y].readings < 10 or filteredPos.z > draught*1.3) then
					if filteredPos.z > draught*1.3 then
						P[filteredPos.x][filteredPos.y].depth = filteredPos.z
						P[filteredPos.x][filteredPos.y].readings = 10
					else
						P[filteredPos.x][filteredPos.y].readings = P[filteredPos.x][filteredPos.y].readings + 1
						P[filteredPos.x][filteredPos.y].read_sum = P[filteredPos.x][filteredPos.y].read_sum + filteredPos.z
						P[filteredPos.x][filteredPos.y].depth = P[filteredPos.x][filteredPos.y].read_sum / P[filteredPos.x][filteredPos.y].readings
						
					end
				elseif not P[filteredPos.x][filteredPos.y] then
					P[filteredPos.x][filteredPos.y] = {depth = filteredPos.z, readings = 1, read_sum = filteredPos.z}
					if filteredPos.z > draught*1.3 then P[filteredPos.x][filteredPos.y].readings = 10 end
					table.insert(record, 1, {filteredPos.x, filteredPos.y})
					if #record > rec_size then
						P[ record[rec_size+1][1] ][ record[rec_size+1][2] ] = nil
						record[rec_size+1] = nil
					end
				end
			end
		end
		
		
		progress = (tick - startTick) % (1 / refreshRate * 60) / (1 / refreshRate*60)
		--print(progress)
		local a = math.floor(#focusPoints * progress + 1)
		local b = math.min( math.floor(#focusPoints * (progress + 1/(60/refreshRate)) + 1), #focusPoints )
		for i = a, b do
			worldPos = {
				x = (nextPos.x + math.cos(nextAzi + focusPoints[i].vesselAngle) * focusPoints[i].vesselDistUnits * displayRange/30 + gridFilter/2) // gridFilter * gridFilter,
				y = (nextPos.y + math.sin(nextAzi + focusPoints[i].vesselAngle) * focusPoints[i].vesselDistUnits * displayRange/30 + gridFilter/2) // gridFilter * gridFilter
			}
			
			
			depth = 0
			depthFound = false
			if P[worldPos.x] and P[worldPos.x][worldPos.y] then
				depth = P[worldPos.x][worldPos.y].depth
				depthFound = true
			elseif useAvgCalc and refreshRate < 30 then
				avgDepth = findAvgDepth(worldPos.x, worldPos.y)
				if avgDepth then
					depth = avgDepth
					depthFound = true
				end
			end
			table.insert(drawPointsNext, {
				depthFound = depthFound,
				depth = depth,
				relx = focusPoints[i].relScreenPosX,
				rely = focusPoints[i].relScreenPosY
				})
		end	
		
		if progress == 0 then
			drawPoints = {}
			for _, point in ipairs(drawPointsNext) do
				table.insert(drawPoints, {
					depthFound = point.depthFound,
					depth = point.depth,
					relx = point.relx,
					rely = point.rely
					})
			end
			drawPointsNext = {}
			
			nextAzi = azimuth
			nextPos = {x = pos.x, y = pos.y}
		end
		
	else
		P = {}
		record = {}
		startTick = tick
		drawPointsNext = {}
		drawPoints = {}
		iter = 0
		nextAzi = azimuth
		nextPos = {x = pos.x, y = pos.y}
	end
	
	
	tick = tick + 1
end

function onDraw()
	w, h = screen.getWidth(), screen.getHeight()
	
	
	if run then
		for _, point in ipairs(drawPoints) do
			if point.depthFound then
				color(((-draught*1.3 + point.depth) - (hi_boundary)) / (lo_boundary - hi_boundary))

			else
				sC(30, 30, 30)
			end
			screen.drawRectF(w/2 + point.relx, h/2 - point.rely, 1, 1)
		end
	end
end







---------------------------------------------------------------------------------------




--Recieves new measurements and calculates positions + througput of composite signal
gN,sN,gB=input.getNumber,output.setNumber,input.getBool
dT=screen.drawText
pi=math.pi
co=math.cos
si=math.sin

tick = 0


lowestDetectable, highestDetectable = 10, 4000
gridFilter, heightFilter = 10, 1
sensorInputStartCh = 9
outStartCh = 9

function multiplyVector(vector, multiplier)
	return {
		x = vector.x * multiplier,
		y = vector.y * multiplier,
		z = vector.z * multiplier
	}
end

function addVectors(...)
	local result = {x = 0, y = 0, z = 0}
	for _, vector in pairs({...}) do
		result.x = result.x + vector.x
		result.y = result.y + vector.y
		result.z = result.z + vector.z
	end
	return result
end





function rotX(x,r)
    return {x[1],co(r)*x[2]-si(r)*x[3],si(r)*x[2]+co(r)*x[3]}
end
function rotY(x,r)
    return {co(r)*x[1]+si(r)*x[3],x[2],-si(r)*x[1]+co(r)*x[3]}
end
function rotZ(x,r)
    return {co(r)*x[1]-si(r)*x[2],si(r)*x[1]+co(r)*x[2],x[3]}
end



function onTick()
	for i = 1, 32 do
		output.setNumber(i, input.getNumber(i))
		output.setBool(i, input.getBool(i))
	end
	
	
	--

    ex,ey,ez=gN(4),gN(5),gN(6)
    
    v1={0,0,1}
    v1=rotZ(rotY(rotX(v1,ex),ey),ez)
    hdg=math.atan(v1[1],v1[3])
    elv=math.atan(v1[2],math.sqrt(v1[1]^2+v1[3]^2))
    
    v2={1,0,0}
    v2=rotZ(rotY(rotX(v2,ex),ey),ez)
    
    v3={1,0,0}
    v3=rotY(rotX(v3,elv),hdg)
    
    crs={v2[2]*v3[3]-v2[3]*v3[2],v2[3]*v3[1]-v2[1]*v3[3],v2[1]*v3[2]-v2[2]*v3[1]}    --sin
	sgn=(v1[1]*crs[1]+v1[2]*crs[2]+v1[3]*crs[3]>=0) and 1 or -1
	crs=math.sqrt(crs[1]^2+crs[2]^2+crs[3]^2)*sgn
    dot=v2[1]*v3[1]+v2[2]*v3[2]+v2[3]*v3[3]    --cos
    rol=math.atan(crs,dot)
    hdg=(-hdg+pi/2)%(pi*2)
    
    --
    
    
    pos = {
    	x = gN(1),	--east
    	y = gN(3),	--north
    	z = gN(2),	--up
    }
    roll = rol	--left
    pitch = elv	--up
    azimuth = hdg	--left
    
    run = gB(3)
    
    
    
	if run then
	    vector = {
			right_noRoll = {
				x = math.cos(azimuth-math.pi/2),
				y = math.sin(azimuth-math.pi/2),
				z = 0
			},
			up_noRoll = {
				x = math.cos(azimuth+math.pi) * math.sin(pitch),
				y = math.sin(azimuth+math.pi) * math.sin(pitch),
				z = math.cos(pitch)
			}
		}
			

		vector.right = {
			x = vector.up_noRoll.x * math.sin(roll) + vector.right_noRoll.x * math.cos(roll),
			y = vector.up_noRoll.y * math.sin(roll) + vector.right_noRoll.y * math.cos(roll),
			z = vector.up_noRoll.z * math.sin(-roll) + vector.right_noRoll.z * math.cos(-roll)
		}

		
		-- print(vector.up_noRoll)
		-- print(dist(vector.right))
		-- print(vector.right)
		
		vector.forward = {
			x = math.cos(azimuth) * math.cos(pitch),
	    	y = math.sin(azimuth) * math.cos(pitch),
	    	z = math.sin(pitch)
	    }
	    
		vector.up = {
			x = vector.up_noRoll.x * math.cos(roll) + vector.right_noRoll.x * math.sin(roll),
			y = vector.up_noRoll.y * math.cos(roll) + vector.right_noRoll.y * math.sin(roll),
			z = vector.up_noRoll.z * math.cos(roll) + vector.right_noRoll.z * math.sin(roll)
		}
		
		--SENSOR ORIENTATION: looking at sensor face - Big arrow facing down, small arrow facing left
	    for i = 9, 32, 3 do
		    measuredDis = gN(i)
		    angleX = gN(1 + i) * math.pi/4		--right
		    angleY = gN(2 + i) * math.pi/4		--up
		    if measuredDis > lowestDetectable and measuredDis < highestDetectable then
			    sensorRelative = {
			    	x = math.sin(angleX) * math.cos(angleY) * measuredDis,	--right
			    	y = math.cos(angleX) * math.cos(angleY) * measuredDis,	--forward
				    z = math.sin(angleY) * measuredDis	--up
				}
				measuredPos = addVectors(
					pos,
					multiplyVector(vector.right, sensorRelative.x),
					multiplyVector(vector.forward, sensorRelative.y),
					multiplyVector(vector.up, sensorRelative.z)
				)
				
				filteredPos = {
			    	x = (measuredPos.x + gridFilter/2) // gridFilter * gridFilter,
			    	y = (measuredPos.y + gridFilter/2) // gridFilter * gridFilter,
			    	z = (measuredPos.z + heightFilter/2) // heightFilter * heightFilter
			    }
			    
			    -- sN(outStartCh + i-1, filteredPos.x)
			    -- sN(outStartCh+1 + i-1, filteredPos.y)
			    -- --sN(10, filteredPos.y)
			    -- sN(outStartCh+2 + i-1, filteredPos.z)
				--print(i, measuredPos)
				
				sN(i, filteredPos.x)
			    sN(i+1, filteredPos.y)
			    sN(i+2, filteredPos.z)
			else
				sN(i, 0)
			    sN(i+1, 0)
			    sN(i+2, 0)
			end
	    end
	end
    
    
    
    
    
    
    
    
    
    
    tick = tick + 1
    if tick % 60 == 0 then
		filteredPosToDisplay = filteredPos
	end
    
    sN(4, roll)
    sN(5, pitch)
    sN(6, azimuth)   
end


function onDraw()
	if run then
		w, h = screen.getWidth(), screen.getHeight()
		dT(1, 1, "X: " .. string.format("%.1f", pos.x))
		dT(1, 7, "Y: " .. string.format("%.1f", pos.y))
		dT(1, 13, "Z: " .. string.format("%.1f", pos.z))
		
		dT(1, 20, "P: " .. string.format("%.1f", pitch))
		dT(1, 26, "A: " .. string.format("%.1f", azimuth))
		dT(1, 32, "R: " .. string.format("%.1f", roll))
		
		dT(1, 39, "MEAS: " .. measuredDis//1)
		dT(1, 45, "A-X: " .. angleX)
		dT(1, 51, "A-Y: " .. angleY)
		
		dT(1, 60, string.format("%.3f", vector.right.x))
		dT(1, 66, string.format("%.3f", vector.right.y))
		dT(1, 72, string.format("%.3f", vector.right.z))
		
		-- if filteredPosToDisplay then
		-- 	--dT(1, h-7, string.format("%.0f", filteredPosToDisplay.x), string.format("%.0f", filteredPosToDisplay.y), string.format("%.0f", filteredPosToDisplay.z))
		-- 	dT(1, h-21, filteredPosToDisplay.x)
		-- 	dT(1, h-15, filteredPosToDisplay.y) 
		-- 	dT(1, h-9, filteredPosToDisplay.z)
		-- end
	else
		dT(1, 1, "run = off")
	end
	
end


----------------------------------------------------------------------

-- Sets sensors scan angles



nSensors = 8
cycleTicks = 150
tick = 0

rows = 45
columns = 30
function getLaserDirection(n)
	local x = (rows * columns * n) % columns / columns
	local y = ((rows * columns * n) // columns / rows)^3
	return x * 2 - 1, -(0.03 + y*0.97)
end

FOV = math.min(90, math.max(20, property.getNumber("Field of view") or 90) ) / 90
brt = property.getNumber("Brightness") or 255
scanLines = 7
cycleTime = 60 // scanLines * scanLines
displayTime = 60 * 2
firstRun = true
--tick = 0

setupMirroring = {
	{x = 0.6, y = -0.2, size = 0.7},
	{x = 0.2, y = -0.2, size = 0.4},
	{x = 0.25, y = -0.4, size = 0.5},
	{x = 0.3, y = -0.6, size = 0.6}
}

aimBoxes = {}
for index, rectangle in ipairs(setupMirroring) do
	for i = -1, 1, 2 do
		local targetIndex = (index + (i+1)/2 * #setupMirroring) // 1
		aimBoxes[targetIndex] = {
			startX = (rectangle.x + rectangle.size/2) * i,
			rangeX = rectangle.size * -i,
			startY = rectangle.y + rectangle.size/2,
			rangeY = -rectangle.size
		}
	end
end


function clamp(value, min, max)
	return math.min(max, (math.max(min, value)))
end
	
function onTick()
	
	run = input.getBool(3)
	roll = input.getNumber(4)-- * (-math.pi*2)	-- CW is positive
	
	if (property.getBool("Display start-up screen") or false) and run and tick < ((startTick or 0) + displayTime) then
		showGraphics = true
	else
		showGraphics = false
		if firstRun then
			startTick = tick
		end
	end
	
	if run then
		if firstRun and showGraphics then
			sensors = 0
			inStartCh = 9
			for sensorID, aimBox in pairs(aimBoxes) do
				aimBox.detected = input.getNumber(inStartCh + (sensorID-1) * 3) ~= 0
				sensors = sensors + (aimBox.detected and 1 or 0)
			end
		end
		
		
		xStep = (tick%cycleTime // scanLines) / scanLines
		yStep = (tick % scanLines / scanLines) / (1-(1/scanLines))
		
		
		outStartCh = 9
    	for i = 1, nSensors do
	    	local x, y = getLaserDirection((tick % cycleTicks / cycleTicks + i/nSensors) % 1)
	    	output.setNumber(outStartCh + (i-1) * 3 + 1, x)
	    	output.setNumber(outStartCh + (i-1) * 3 + 2, y)
    	end	
	
		-- for sensorID, aimBox in pairs(aimBoxes) do
		-- 	aimXNoRoll = aimBox.startX + aimBox.rangeX * xStep
		-- 	aimYNoRoll = aimBox.startY + aimBox.rangeY * yStep
		-- 	length = math.sqrt(aimXNoRoll^2 + aimYNoRoll^2)
		-- 	angleNoRoll = math.atan(aimYNoRoll, aimXNoRoll)
		-- 	aimX = clamp(math.cos(angleNoRoll + roll) * length * FOV, -1, 1)
		-- 	aimY = clamp(math.sin(angleNoRoll + roll) * length * FOV, -1, 1)
			
			
			--output.setNumber(outStartCh + (sensorID-1)*3 + 1, input.getNumber(1))--aimX)
			--output.setNumber(outStartCh + (sensorID-1)*3 + 2, input.getNumber(2))--aimY)
			
			--output.setNumber(outStartCh + (sensorID-1)*3 + 1, math.random(-70, 70)/100)--aimX)
			
			--output.setNumber(outStartCh + (sensorID-1)*3 + 2, math.random(-40, 0)/100)--aimY)
			
			--output.setNumber(outStartCh + (sensorID-1)*3 + 2, math.random(-70, -10)/100)
			
			
			
			
			
			
		-- end
		
		firstRun = false
	end
	
	output.setBool(3, run and not showGraphics)
	tick = tick + 1
end



sC = screen.setColor
dTB = screen.drawTextBox

function onDraw()
	w, h = screen.getWidth()/2, screen.getHeight()/2
	len = math.min(w, h)
	
	if showGraphics then
		sC(255, 255, 255)
		dTB(
			w - len, 
			h - len + 3, 
			len * 2,
			12,
			"VERSION 1.0\n-------------------",
			0, 0)
		
		sC(0, 255, 0)
		dTB(
			w - len, 
			h - len + 19, 
			len * 2,
			6,
			"FOV:   " .. string.format("%.0f", FOV*90) .. "'",
			0, 0)
		
		dTB(
			w - len, 
			h - len + 26, 
			len * 2,
			6,
			"SENSORS: " .. string.format("%.0f", sensors or 0),
			0, 0)
		
		
		for _, aimBox in ipairs(aimBoxes) do
			if aimBox.detected then
				sC(0, 255, 0,  math.abs(10/aimBox.rangeX))
				screen.drawRectF(
					w + aimBox.startX * len,
					h - aimBox.startY * len,
					aimBox.rangeX * len, 
					-aimBox.rangeY * len
					)
			end
		end
		
		
		colors = #aimBoxes
		colorNo = 0
		for sensorID, aimBox in ipairs(aimBoxes) do
			startX = aimBox.startX
			startY = aimBox.startY
			rangeX = aimBox.rangeX
			rangeY = aimBox.rangeY
			
			if aimBox.detected then
				sC(255 / colors * colorNo, 255 - 255 / colors * colorNo, 0)
			else
				sC(255, 0, 0)
				screen.drawLine(
				w + startX * len,
				h - startY * len,
				w + (startX + rangeX) * len,
				h - (startY + rangeY) * len
				)
				screen.drawLine(
				w + startX * len,
				h - (startY + rangeY) * len,
				w + (startX + rangeX) * len,
				h - startY * len
				)
			end
			
			
			screen.drawRectF(
				w + (startX + rangeX/2) * len ,
				h - (startY + rangeY/2) * len,
				1, -1
				)
			screen.drawRect(
				w + startX * len,
				h - startY * len,
				rangeX * len, 
				-rangeY * len
				)
			screen.drawText(
				w + (startX + (sensorID <= 4 and 0 or rangeX)) * len + 1,
				h - startY * len + 1,
				sensorID
				)
			colorNo = colorNo + 1
		end
		
		sC(0, 0, 0, 255 - brt*255)
		screen.drawRectF(1, 1, w*2, h*2)




------------------------------------------------------


gN = input.getNumber
sN = output.setNumber
gB = input.getBool
sB = output.setBool
sC = screen.setColor
dRF = screen.drawRectF
dR = screen.drawRect
dT = screen.drawText
dTB = screen.drawTextBox
dL = screen.drawLine
f = math.floor
pi2 = math.pi / 2
cos = math.cos
sin = math.sin
gridFilter, heightFilter = 10, 1
prevPos = { x = 0, y = 0 }
pos = { x = 0, y = 0 }
tick = 0
displayRange = 300
vertDispDepth = -200
coll_warn_startTick = -math.huge
--coll_warn_secs = 10




refreshRate = property.getNumber("Refresh rate") --per seconds
useAvgCalc = property.getBool("Fill empty pixels with average values")
draught = property.getNumber("Draught (M)")
coll_warn_secs = property.getNumber("Warning sensitivity") * 20
brt = property.getNumber("Brightness") or 0

P = {}
record = {}


function check(x, y, w, h)
    return touchX >= x and touchX <= x + (w or 0) and touchY >= y and touchY <= y + (h or 0)
end

function color(n)
    if n < 0 then
        sC(255, 0, 0)
    elseif n <= 1 then
        if n < 1 / 8 then
            a = { 255, 255, 0 } --yellow
            b = { 0, 255, 0 }
        elseif n < 2 / 8 then
            a = { 0, 255, 0 }
            b = { 0, 153, 76 } --dark green
        elseif n < 3 / 8 then
            a = { 0, 153, 76 }
            b = { 0, 255, 255 } --light blue
        elseif n < 4 / 8 then
            a = { 0, 255, 255 }
            b = { 0, 76, 153 } --blue
        elseif n < 5 / 8 then
            a = { 0, 76, 153 }
            b = { 0, 0, 255 } --dark blue
        elseif n < 6 / 8 then
            a = { 0, 0, 255 }
            b = { 76, 0, 153 } --purple
        elseif n < 7 / 8 then
            a = { 76, 0, 153 }
            b = { 255, 0, 255 } --pink
        else
            a = { 255, 0, 255 }
            b = { 80, 0, 50 } --dark pink
        end

        dr = b[1] - a[1]
        dg = b[2] - a[2]
        db = b[3] - a[3]

        k = n / (1 / 8) - f(n / (1 / 8))
        sC(
            a[1] + dr * k,
            a[2] + dg * k,
            a[3] + db * k
        )
    else
        sC(0, 0, 0)
    end
end

drawCenterY = -50
pixelRadius = 71
FOV = math.rad(43)
cutoffY = 30
vehiclerelativePosY = drawCenterY + pixelRadius -
cutoffY --Relative to drawCenterY (center of radar display calculation)

focusPoints = {}
recordKeeper = {}


-- P = {
-- 	[50] = {
-- 		--[0] = {depth = -10},
-- 		--[40] = {depth = -30},
-- 		[10] = {depth = 1}
-- 	}--,
-- 	-- [170] = {
-- 	-- 	[-20] = {depth = -30},
-- 	-- 	[30] = {depth = -30},
-- 	-- 	[40] = {depth = -50}
-- 	-- },
-- 	-- [160] = {
-- 	-- 	[-40] = {depth = -50},
-- 	-- 	[0] = {depth = 10},
-- 	-- 	[20] = {depth = 100}
-- 	-- },
-- 	-- [250] = {
-- 	-- 	[-80] = {depth = - 100}
-- 	-- }
-- }


function dButton(x, y, text, var)
        sC(255, 255, 255)
        if var then
            dRF(x, y, 5, 5)
        else
            dR(x, y, 5, 5)
        end
        sC(0, 255, 0)
        dT(x + 1, y, text)
    end

for angle = -FOV / 2, FOV / 2, 0.01 do
    for lengthUnit = pixelRadius - cutoffY, pixelRadius, 0.5 do
        if math.cos(angle) * lengthUnit > pixelRadius - cutoffY then
            local x = ((math.cos(angle + math.pi / 2) * lengthUnit) + 0.5) // 1
            local y = ((drawCenterY + (math.sin(angle + math.pi / 2) * lengthUnit)) + 0.5) // 1

            if not recordKeeper[x] then
                recordKeeper[x] = {}
            end

            if recordKeeper[x] and not recordKeeper[x][y] then
                vesselAngle = math.atan(y - vehiclerelativePosY, x) - math.pi / 2
                vesselDistUnits = math.sqrt(x ^ 2 + (y - vehiclerelativePosY) ^ 2)

                table.insert(focusPoints, {
                    vesselAngle = vesselAngle,
                    vesselDistUnits = vesselDistUnits,
                    relScreenPosX = x,
                    relScreenPosY = y,
                    depth = 0
                })
                recordKeeper[x][y] = true
            end
        end
    end
end
recordKeeper = nil

function findAvgDepth(x, y)
    local surroundingPoints = {}

    local i = 1
    local maxIterations = 5
    local gf = gridFilter
    while #surroundingPoints < 3 and i <= maxIterations do
        for y1 = y - i * gf, y + i * gf, i * 2 * gf do
            for x1 = x - (i - 1) * gf, x + (i - 1) * gf, gf do
                if P[x1] and P[x1][y1] then
                    table.insert(surroundingPoints, P[x1][y1].depth)
                end
            end
        end

        for x1 = x - i * gf, x + i * gf, i * 2 * gf do
            for y1 = y - i * gf, y + i * gf, gf do
                if P[x1] and P[x1][y1] then
                    table.insert(surroundingPoints, P[x1][y1].depth)
                end
            end
        end


        i = i + 1
    end

    if #surroundingPoints ~= 0 then
        local totalDepth = 0
        for _, depth in ipairs(surroundingPoints) do
            totalDepth = totalDepth + depth
        end
        local avg = totalDepth / #surroundingPoints
        return avg
    else
        return false
    end
end


function onTick()
	hasPressed = not isPressing
    isPressing = gB(1) or gB(2)
    click = isPressing and hasPressed
    touchX = gN(7)
    touchY = gN(8)
    hi_boundary, lo_boundary = gN(4),gN(5)
    run = gB(3) and tick > 1 --testing
    draught = 0                         --
    rec_size = 10000

	prevPos = {x = pos.x, y = pos.y}
    pos = {
        x = gN(1), --east
        y = gN(3)  --north
    }
    -- Looking towards laser sensor from behind
    azimuth = gN(6) --left


    collisionWarnMuted = gB(4)
    
	velocity = 10--math.sqrt((pos.x - prevPos.x)^2 + (pos.y - prevPos.y)^2) * 60 --m/s

    if run then
        for i = 9, 32, 3 do
            filteredPos = {

                x = gN(i) // 1,
                y = gN(i + 1) // 1,
                z = gN(i + 2) // 1
            }
            if filteredPos.x ~= 0 then
                if not P[filteredPos.x] then
                    P[filteredPos.x] = {}
                end

                if P[filteredPos.x][filteredPos.y] and P[filteredPos.x][filteredPos.y].readings < 10 then
                    if P[filteredPos.x][filteredPos.y].depth > draught - 0.5 then
                        P[filteredPos.x][filteredPos.y].depth = filteredPos.z
                        P[filteredPos.x][filteredPos.y].readings = 10
                    else
                        P[filteredPos.x][filteredPos.y].readings = P[filteredPos.x][filteredPos.y].readings + 1
                        P[filteredPos.x][filteredPos.y].read_sum = P[filteredPos.x][filteredPos.y].read_sum +
                            filteredPos.z
                        P[filteredPos.x][filteredPos.y].depth = P[filteredPos.x][filteredPos.y].read_sum /
                            P[filteredPos.x][filteredPos.y].readings
                    end
                elseif not P[filteredPos.x][filteredPos.y] then
                    P[filteredPos.x][filteredPos.y] = { depth = filteredPos.z, readings = 1, read_sum = filteredPos.z }
                    if filteredPos.z > draught - 0.5 then P[filteredPos.x][filteredPos.y].readings = 10 end
                    table.insert(record, 1, { filteredPos.x, filteredPos.y })
                    if #record > rec_size then
                        P[record[rec_size + 1][1]][record[rec_size + 1][2]] = nil
                        record[rec_size + 1] = nil
                    end
                end
            end
        end
        
        progress = (tick - startTick) % (1 / refreshRate * 60) / (1 / refreshRate*60)
        if progress == 0 then
        	vertDispPoints = {}
			for dis = 10, displayRange, (displayRange-10)/39 do
				worldPos = {
					x = (pos.x + math.cos(azimuth) * dis + gridFilter/2) // gridFilter * gridFilter,
					y = (pos.y + math.sin(azimuth) * dis + gridFilter/2) // gridFilter * gridFilter
				}
			
				depthFound = false
				if P[worldPos.x] and P[worldPos.x][worldPos.y] then
					depth = P[worldPos.x][worldPos.y].depth
					depthFound = true
				elseif useAvgCalc and refreshRate < 30 then
					avgDepth = findAvgDepth(worldPos.x, worldPos.y)
					if avgDepth then
						depth = avgDepth
						depthFound = true
					end
				end
				table.insert(vertDispPoints, {
					depthFound = depthFound,
					depth = depth,
					dis = dis
					})
			end
			--print(vertDispPoints)
        end
	
		coll_warn = false
		if not collisionWarnMuted then
			for dis = 10, 300, 7 do
				for i = -1, 1 do
					worldPos = {
							x = (pos.x + math.cos(azimuth + math.pi/2*i) * 5 + math.cos(azimuth) * dis + gridFilter/2) // gridFilter * gridFilter,
							y = (pos.y + math.sin(azimuth + math.pi/2*i) * 5 + math.sin(azimuth) * dis + gridFilter/2) // gridFilter * gridFilter
						}
					
					if P[worldPos.x] and P[worldPos.x][worldPos.y] then
						if P[worldPos.x][worldPos.y].depth > draught*1.3 and (dis / velocity) < coll_warn_secs then
							coll_warn = true
						end
					end
				end
			end
		end
	
	
	else
		P = {}
		record = {}
		startTick = tick
		vertDispPoints = {}
    end
    
    
    if displayRange >= 1500 then
    	zoomStep = 500
    else
    	zoomStep = 100
    end
    
    zoom_in = isPressing and check(w / 2 - 16, 2, 7, 7)
    if zoom_in and click then
    	displayRange = math.max(displayRange - zoomStep, 100)
    end
    
    zoom_out = isPressing and check(w / 2 + 12, 2, 2, 7, 7)
    if zoom_out and click then
    	displayRange = math.min(displayRange + zoomStep, 5000)
    end
    
    higher = isPressing and check(w / 2 - 27, h / 2 + 15, 7, 7)
    if higher and click then
    	vertDispDepth = math.min(vertDispDepth + 100, -100)
    end
    
    lower = isPressing and check(w / 2 - 27, h / 2 + 23, 7, 7)
    if lower and click then
    	vertDispDepth = math.max(vertDispDepth - 100, -1000)
    end
    
    showOptionsPage = showOptionsPagePressed and not isPressing
    showOptionsPagePressed = isPressing and check(2, 2, 7, 7)
    
    coll_warn_dur = 60
    if coll_warn then
    	coll_warn_startTick = tick
    end
    
	coll_warn_active = (tick - coll_warn_startTick) < coll_warn_dur 
	
	
	
	
	
    	
    
    
    sN(1, displayRange)
    sB(1, showOptionsPage)
    sB(2, coll_warn_active)

    tick = tick + 1
end



function onDraw()
    w, h = screen.getWidth(), screen.getHeight()



	dButton(2, 2, "", showOptionsPagePressed)
    sC(0, 255, 0)
    dRF(3, 3, 3, 3)

	if collisionWarnMuted then
	    sC(255, 255, 255)
	    screen.drawCircle(w-5, 5, 3)
	    sC(255, 0, 0)
	    dT(w-6, 3, "!")
	end

    sC(255, 255, 255)
    dT(w / 2 + 23, h / 2 + 15, 0)
    dT(w / 2 + 23, h / 2 + 23, string.format("%.0f", -vertDispDepth / 100))

    dT(4, h / 2 - 8, string.format("%.0f", math.abs(hi_boundary) / 100))
    dT(4, h / 2 + 2, string.format("%.0f", math.abs(lo_boundary) / 100))

    dTB(1, 2, w, 6, displayRange, 0, 0)
    dButton(w / 2 - 16, 2, "+", zoom_in)
    
    --screen.drawRect(w / 2 - 16, 2, 5, 5)
    
    dButton(w / 2 + 12, 2, "-", zoom_out)
    dButton(w / 2 - 27, h / 2 + 15, "+", higher)
    dButton(w / 2 - 27, h / 2 + 23, "-", lower)

    steps = 20
    startI = -0.1
    endI = 1
    for i = 0, 1, 1 / steps do
        color(startI + i * (endI - startI))
        dRF(2, h / 2 - 10 + i * steps, 1, 1)
    end



    drawCenterY = -50
    pixelRadius = 71
    FOV = math.rad(43)
    cutoffY = 30
    sC(255, 255, 255)

    dL(
        w / 2 + math.cos(math.pi / 2 + FOV / 2) * 71,
        h / 2 + 50 - math.sin(math.pi / 2 + FOV / 2) * 71,
        w / 2 + math.cos(math.pi / 2 + FOV / 2) * 43,
        h / 2 + 50 - math.sin(math.pi / 2 + FOV / 2) * 43
    )

    dL(
        w / 2 + math.cos(math.pi / 2 - FOV / 2 * 1.02) * 71 + 0.3,
        h / 2 + 50 - math.sin(math.pi / 2 - FOV / 2 * 1.02) * 71,
        w / 2 + math.cos(math.pi / 2 - FOV / 2 * 1.02) * 43 + 1,
        h / 2 + 50 - math.sin(math.pi / 2 - FOV / 2 * 1.02) * 43
    )

    dL(
        w / 2 + math.cos(math.pi / 2 + FOV / 2) * 43,
        h / 2 + 50 - math.sin(math.pi / 2 + FOV / 2) * 43,
        w / 2 + math.cos(math.pi / 2 - FOV / 2) * 43 + 2,
        h / 2 + 50 - math.sin(math.pi / 2 - FOV / 2) * 43
    )

    for i = -FOV / 2, FOV / 2, FOV / 60 do
        dRF(
            w / 2 + math.cos(math.pi / 2 + i) * 71,
            h / 2 + 50 - math.sin(math.pi / 2 + i) * 71,
            1,
            1
        )
    end
    
    

	sC(255, 0, 0)
	for _, point in ipairs(vertDispPoints) do
		if point.depthFound and point.depth >= vertDispDepth then
			if point.depth > draught * 1.3 then
				y = -1
				sC(255, 0, 0)
			elseif point.depth > -20 then
				y = 13 * point.depth / vertDispDepth
				sC(255, 255, 0)
			else
				y = 13 * point.depth / vertDispDepth
				sC(0, 255, 0)
			end
			
			dRF(
				w / 2 - 20 + 39 * point.dis/displayRange,
				h / 2 + 16 + y,
				1,
				1
			)
		end
	end

    sC(255, 255, 255)
    dR(w / 2 - 19, h / 2 + 14, 39, 15)
    dL(w / 2 - 20, h / 2 + 16, w / 2 - 17, h / 2 + 16)
    dL(w/2, h/2+9, w/2, h/2+12)

    if coll_warn_active then
    	sC(0,0,0)
    	dRF(w/2-27, 8, 55, 16)
    	sC(255,0,0)
    	dR(w/2-27, 8, 55, 16)
    	sC(255,255,255)
    	dTB(w/2-27, 10, 55, 16, "COLLISION", 0)
    	dTB(w/2-27, 16, 55, 16, "AHEAD", 0)
    end



    sC(0, 0, 0, (1-brt) * 255)
    dRF(1, 1, w, h)
end








-------------------------------------------------


--Options page

gB,gN,sN,sC,dTB,dT,dR,dRF,dL=input.getBool,input.getNumber,output.setNumber,screen.setColor,screen.drawTextBox,screen.drawText,screen.drawRect,screen.drawRectF,screen.drawLine
hi_boundary,lo_boundary=0,-200
w, h = 0, 0

collisionWarnMuted = not property.getBool("Collision warning")

function check(x,y,w,h)
	return (touchX >= x and touchX <= x+w and touchY >= y and touchY <= y+h)
end

function dButton(x,y,text,var)
	sC(255,255,255)
	if var then
		dRF(x, y, 5,5)
	else
		dR(x, y, 5,5)
	end
	sC(0,255,0)
	dT(x+1, y, text)
end

function onTick()
	hasPressed = isPressing
	isPressing = gB(1) or gB(2)
	click = isPressing and not hasPressed
	
	brt = gN(5)
	
	touchX = gN(3) + gN(5)
	touchY = gN(4) + gN(6)
	
	
	alarmPressed = isPressing and check(w/2+2, h/2-17, 20, 15)
	if alarmPressed and click then 
		collisionWarnMuted = not collisionWarnMuted 
	end
	
	hi_inc = isPressing and check(w/2-5, h/2-18, 6, 6)
	if hi_inc then
		if click and hi_boundary<0 then
			hi_boundary = hi_boundary + 100
		end
	end
	
	hi_dec = isPressing and check(w/2-5, h/2-11, 6, 6)
	if hi_dec then
		if click and hi_boundary>lo_boundary+100 then
			hi_boundary = hi_boundary - 100
		end
	end
	
	lo_inc = isPressing and check(w/2-5, h/2+12, 6, 6)
	if lo_inc then
		if click and lo_boundary<hi_boundary-100 then
			lo_boundary = lo_boundary + 100
		end
	end
	
	lo_dec = isPressing and check(w/2-5, h/2+19, 6, 6)
	if lo_dec then
		if click and lo_boundary>-500 then
			lo_boundary = lo_boundary - 100 
		end
	end
	
	showOptionsPage = showOptionsPagePressed and not isPressing
	showOptionsPagePressed = isPressing and check(2,2,6,6)


	
	sN(1, hi_boundary)
	sN(2, lo_boundary)
	
	output.setBool(1, showOptionsPage)
	output.setBool(2, collisionWarnMuted)
end

function onDraw()
	w, h = screen.getWidth(), screen.getHeight()
	
	dButton(2,2, "", showOptionsPagePressed)
	sC(0,255,0)
	dRF(3,3,3,3)
	
	sC(255,255,255)
	dTB(1,1,w,10,"OPTIONS",0)
	
	dButton(w/2-5, h/2-18, "+", hi_inc)
	dButton(w/2-5, h/2-11, "-", hi_dec)
	dButton(w/2-5,h/2+12,"+",lo_inc)
	dButton(w/2-5,h/2+19,"-",lo_dec)
	
	sC(0,255,0)
	dR(w/2-27,hi_boundary/-500*35-18+h/2,20,7)
	dL(w/2-30,hi_boundary/-500*35-15+h/2,w/2-27,hi_boundary/-500*35+h/2-15)
	dR(w/2-27,lo_boundary/-500*35-18+h/2,20,7)
	dL(w/2-30,lo_boundary/-500*35-15+h/2,w/2-27,lo_boundary/-500*35+h/2-15)
	dL(w/2-30,hi_boundary/-500*35-15+h/2,w/2-30,lo_boundary/-500*35+h/2-15)
	
	sC(255,255,255)
	for i=0,5 do
		dTB(w/2-27,h/2+i*7-17,20,5,i*100,0)	
	end
	
	
	
	dTB(w/2+2,h/2-17,28,5,"ALARM",0)
	if alarmPressed then
		dRF(w/2+2,h/2-18,28,15)
	else
		dR(w/2+2,h/2-18,28,15)
	end
	
	if collisionWarnMuted then
		sC(255,0,0)
		txt = "MUTE"
	else
		sC(0,255,0)
		txt = "ON"
	end
	dTB(w/2+2,h/2-10,28,5,txt,0)


	sC(0,0,0,brt)
	dRF(1,1,70,70)


	
--[[	sC(255,255,255)
	dT(2,2,"A")
	sC(255,0,0)
	dL(1,7,6,1)
	dL(1,1,6,7)]]
	

	
end

